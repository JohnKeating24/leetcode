/*
1 时间复杂度 O(n),空间复杂度 O(1)？
2 算法原理:
    1 后序遍历要保证左右中的次序，故对每一个root节点，	
    要先完成对其左、右孩子的访问，且左孩子要先于右孩子的访问，才能访问root节点。故对每一个root节点，
	2 若其右孩子已经访问，则访问root；
	否则先将root压入cur，首先访问root的右孩子(队列结构的设计使得自动先访问了左孩子)。
3 算法步骤：
  1 初始化，将头节点root节点压入队列cur,
    cur:存储当前层的节点，用于处理
    next:暂时存储下一层的节点，以传递给cur
    level:存储当前层的节点值，用于返回结果
  2 在每一层：将cur中的每一节点弹出，节点值存入level;
  同时将将弹出节点的左、右节点(若存在)先后
  压入next；直至cur为空。
  3 一层处理完毕；level先入result,再清空；进入下一层，重复2
  4 重复2、3，直至下一层节点的存储为空
4 注意：cur/next：元素类型是TreeNode *,level:元素类型是int，队列是先进先出：和栈不同
*/

