/*
Morris遍历
原理：要使用O(1)空间进行遍历，最大的难点在于，遍历到子节点的时候怎样重新返回到父节点
（假设节点中没有指向父节点的p指针），由于不能用栈作为辅助空间。
为了解决这个问题，Morris方法用到了线索二叉树（threaded binary tree）的概念。
在Morris方法中不需要为每个节点额外分配指针指向其前驱（predecessor）和后继节点（successor），
只需要利用叶子节点中的左右空指针指向某种顺序遍历下的前驱节点或后继节点就可以了。

Morris中序遍历
空间复杂度O(1)
原理：通过利用叶子节点的空right指针，指向中序遍历的后继节点，从而避免了对 stack 的依赖。
步骤：
1 如果当前节点cur的左孩子为空，则输出当前节点并将其右孩子作为当前节点。
  //满足左中右的次序
2 如果当前节点cur的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点node。
  2.1 如果前驱节点node的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。
    	//建立了root的前驱到root的链接。再进入到root->left,递归处理
	2.2 如果前驱节点node的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。输出当前节点。
		  当前节点更新为当前节点的右孩子。
		  //若已经建立链接，则删除链接；访问节点；更新节点。
3 重复以上1、2直到当前节点为空。
*/
